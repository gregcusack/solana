
-    pub fn set_entrypoint(&self, entrypoint: LegacyContactInfo) {
+    pub fn set_entrypoint(&self, entrypoint: ContactInfo) {
         self.set_entrypoints(vec![entrypoint]);
     }
 
-    pub fn set_entrypoints(&self, entrypoints: Vec<LegacyContactInfo>) {
+    pub fn set_entrypoints(&self, entrypoints: Vec<ContactInfo>) {
         *self.entrypoints.write().unwrap() = entrypoints;
     }
 
@@ -666,7 +700,7 @@ impl ClusterInfo {
             *instance = NodeInstance::new(&mut thread_rng(), id, timestamp());
         }
         *self.keypair.write().unwrap() = new_keypair;
-        self.my_contact_info.write().unwrap().set_pubkey(id);
+        self.my_contact_info.write().unwrap().hot_swap_pubkey(id);
 
         self.insert_self();
         self.push_message(CrdsValue::new_signed(
@@ -695,7 +729,7 @@ impl ClusterInfo {
 
     pub fn lookup_contact_info<F, Y>(&self, id: &Pubkey, map: F) -> Option<Y>
     where
-        F: FnOnce(&LegacyContactInfo) -> Y,
+        F: FnOnce(&ContactInfo) -> Y,
     {
         let gossip_crds = self.gossip.crds.read().unwrap();
         gossip_crds.get(*id).map(map)
@@ -704,7 +738,7 @@ impl ClusterInfo {
     pub fn lookup_contact_info_by_gossip_addr(
         &self,
         gossip_addr: &SocketAddr,
-    ) -> Option<LegacyContactInfo> {
+    ) -> Option<ContactInfo> {
         let gossip_crds = self.gossip.crds.read().unwrap();
         let mut nodes = gossip_crds.get_nodes_contact_info();
         nodes
@@ -771,7 +805,7 @@ impl ClusterInfo {
                         ""
                     },
                     now.saturating_sub(last_updated),
-                    node.pubkey(),
+                    node.pubkey().to_string(),
                     if let Some(node_version) = node_version {
                         node_version.to_string()
                     } else {
@@ -833,7 +867,7 @@ impl ClusterInfo {
                             .unwrap_or_else(|| String::from("none")),
                         if node.pubkey() == &my_pubkey { "me" } else { "" },
                         now.saturating_sub(last_updated),
-                        node.pubkey(),
+                        node.pubkey().to_string(),
                         if let Some(node_version) = node_version {
                             node_version.to_string()
                         } else {
@@ -855,7 +889,7 @@ impl ClusterInfo {
         format!(
             "IP Address        |Age(ms)| Node identifier                              \
              | Version |Gossip|TPUvote| TPU  |TPUfwd| TVU  |TVU Q |ServeR|ShredVer\n\
-             ------------------+-------+---------------------------------------\
+             ------------------+-------+----------------------------------------------\
              +---------+------+-------+------+------+------+------+------+--------\n\
              {}\
              Nodes: {}{}{}",
@@ -983,6 +1017,26 @@ impl ClusterInfo {
         Ok(())
     }

 
-    pub fn get_node_version(&self, pubkey: &Pubkey) -> Option<solana_version::LegacyVersion2> {
+    pub fn get_node_version(&self, pubkey: &Pubkey) -> Option<solana_version::Version> {
         let gossip_crds = self.gossip.crds.read().unwrap();
-        if let Some(version) = gossip_crds.get::<&Version>(*pubkey) {
-            return Some(version.version.clone());
-        }
-        let version: &crds_value::LegacyVersion = gossip_crds.get(*pubkey)?;
-        Some(version.version.clone().into())
+        gossip_crds
+            .get::<&ContactInfo>(*pubkey)
+            .map(ContactInfo::version)
+            .cloned()
+            .or_else(|| {
+                gossip_crds
+                    .get::<&Version>(*pubkey)
+                    .map(|entry| entry.version.clone())
+                    .or_else(|| {
+                        gossip_crds
+                            .get::<&crds_value::LegacyVersion>(*pubkey)
+                            .map(|entry| entry.version.clone())
+                            .map(solana_version::LegacyVersion2::from)
+                    })
+                    .map(solana_version::Version::from)
+            })
     }
 
     fn check_socket_addr_space<E>(&self, addr: &Result<SocketAddr, E>) -> bool {
@@ -1282,7 +1358,7 @@ impl ClusterInfo {
     }
 
     /// all validators that have a valid rpc port regardless of `shred_version`.
-    pub fn all_rpc_peers(&self) -> Vec<LegacyContactInfo> {
+    pub fn all_rpc_peers(&self) -> Vec<ContactInfo> {
         let self_pubkey = self.id();
         let gossip_crds = self.gossip.crds.read().unwrap();
         gossip_crds
@@ -1295,7 +1371,7 @@ impl ClusterInfo {
     }
 
     // All nodes in gossip (including spy nodes) and the last time we heard about them
-    pub fn all_peers(&self) -> Vec<(LegacyContactInfo, u64)> {
+    pub fn all_peers(&self) -> Vec<(ContactInfo, u64)> {
         let gossip_crds = self.gossip.crds.read().unwrap();
         gossip_crds
             .get_nodes()
@@ -1303,7 +1379,7 @@ impl ClusterInfo {
             .collect()
     }
 
-    pub fn gossip_peers(&self) -> Vec<LegacyContactInfo> {
+    pub fn gossip_peers(&self) -> Vec<ContactInfo> {
         let me = self.id();
         let gossip_crds = self.gossip.crds.read().unwrap();
         gossip_crds
@@ -1315,7 +1391,7 @@ impl ClusterInfo {
     }
 
     /// all validators that have a valid tvu port regardless of `shred_version`.
-    pub fn all_tvu_peers(&self) -> Vec<LegacyContactInfo> {
+    pub fn all_tvu_peers(&self) -> Vec<ContactInfo> {
         let self_pubkey = self.id();
         self.time_gossip_read_lock("all_tvu_peers", &self.stats.all_tvu_peers)
             .get_nodes_contact_info()
@@ -1328,7 +1404,7 @@ impl ClusterInfo {
     }
 
     /// all validators that have a valid tvu port and are on the same `shred_version`.
-    pub fn tvu_peers(&self) -> Vec<LegacyContactInfo> {
+    pub fn tvu_peers(&self) -> Vec<ContactInfo> {
         let self_pubkey = self.id();
         let self_shred_version = self.my_shred_version();
         self.time_gossip_read_lock("tvu_peers", &self.stats.tvu_peers)
@@ -1343,7 +1419,7 @@ impl ClusterInfo {
     }
 
     /// all tvu peers with valid gossip addrs that likely have the slot being requested
-    pub fn repair_peers(&self, slot: Slot) -> Vec<LegacyContactInfo> {
+    pub fn repair_peers(&self, slot: Slot) -> Vec<ContactInfo> {
         let _st = ScopedTimer::from(&self.stats.repair_peers);
         let self_pubkey = self.id();
         let self_shred_version = self.my_shred_version();
@@ -1364,7 +1440,7 @@ impl ClusterInfo {
             .collect()
     }
 
-    fn is_spy_node(node: &LegacyContactInfo, socket_addr_space: &SocketAddrSpace) -> bool {
+    fn is_spy_node(node: &ContactInfo, socket_addr_space: &SocketAddrSpace) -> bool {
         ![
             node.tpu(contact_info::Protocol::UDP),
             node.gossip(),
@@ -1378,7 +1454,7 @@ impl ClusterInfo {
     }
 
     /// compute broadcast table
-    pub fn tpu_peers(&self) -> Vec<LegacyContactInfo> {
+    pub fn tpu_peers(&self) -> Vec<ContactInfo> {
         let self_pubkey = self.id();
         let gossip_crds = self.gossip.crds.read().unwrap();
         gossip_crds
@@ -1414,7 +1490,7 @@ impl ClusterInfo {
     fn append_entrypoint_to_pulls(
         &self,
         thread_pool: &ThreadPool,
-        pulls: &mut HashMap<LegacyContactInfo, Vec<CrdsFilter>>,
+        pulls: &mut Vec<(ContactInfo, Vec<CrdsFilter>)>,
     ) {
         const THROTTLE_DELAY: u64 = CRDS_GOSSIP_PULL_CRDS_TIMEOUT_MS / 2;
         let entrypoint = {
@@ -1446,10 +1522,14 @@ impl ClusterInfo {
                 .pull
                 .build_crds_filters(thread_pool, &self.gossip.crds, MAX_BLOOM_SIZE)
         } else {
-            pulls.values().flatten().cloned().collect()
+            pulls
+                .iter()
+                .flat_map(|(_, filters)| filters)
+                .cloned()
+                .collect()
         };
         self.stats.pull_from_entrypoint_count.add_relaxed(1);
-        pulls.insert(entrypoint, filters);
+        pulls.push((entrypoint, filters));
     }
 
     /// Splits an input feed of serializable data into chunks where the sum of
@@ -1532,8 +1612,13 @@ impl ClusterInfo {
                 .unwrap_or_default()
         };
         self.append_entrypoint_to_pulls(thread_pool, &mut pulls);
-        let num_requests = pulls.values().map(Vec::len).sum::<usize>() as u64;
+        let num_requests = pulls
+            .iter()
+            .map(|(_, filters)| filters.len())
+            .sum::<usize>() as u64;
         self.stats.new_pull_requests_count.add_relaxed(num_requests);
+        // TODO: Use new ContactInfo once the cluster has upgraded to:
+        // https://github.com/anza-xyz/agave/pull/803
         let self_info = LegacyContactInfo::try_from(&self.my_contact_info())
             .map(CrdsData::LegacyContactInfo)
             .expect("Operator must spin up node with valid contact-info");
@@ -1588,7 +1673,7 @@ impl ClusterInfo {
             push_messages
                 .into_iter()
                 .filter_map(|(pubkey, messages)| {
-                    let peer: &LegacyContactInfo = gossip_crds.get(pubkey)?;
+                    let peer: &ContactInfo = gossip_crds.get(pubkey)?;
                     Some((peer.gossip().ok()?, messages))
                 })
                 .collect()
@@ -1744,7 +1829,7 @@ impl ClusterInfo {
             .read()
             .unwrap()
             .iter()
-            .map(LegacyContactInfo::pubkey)
+            .map(ContactInfo::pubkey)
             .copied()
             .chain(std::iter::once(self.id()))
             .collect();
@@ -2258,7 +2343,6 @@ impl ClusterInfo {
         }
     }
 
-    #[allow(clippy::needless_collect)]
     fn handle_batch_push_messages(
         &self,
         messages: Vec<(Pubkey, Vec<CrdsValue>)>,
@@ -2313,7 +2397,7 @@ impl ClusterInfo {
                     .into_par_iter()
                     .with_min_len(256)
                     .filter_map(|(from, prunes)| {
-                        let peer: &LegacyContactInfo = gossip_crds.get(from)?;
+                        let peer: &ContactInfo = gossip_crds.get(from)?;
                         let mut prune_data = PruneData {
                             pubkey: self_pubkey,
                             prunes,
@@ -2328,9 +2412,6 @@ impl ClusterInfo {
                     .collect()
             })
         };
-        if prune_messages.is_empty() {
-            return;
-        }
         let mut packet_batch = PacketBatch::new_unpinned_with_recycler_data_and_dests(
             recycler,
             "handle_batch_push_messages",
@@ -2360,7 +2441,9 @@ impl ClusterInfo {
         self.stats
             .packets_sent_push_messages_count
             .add_relaxed((packet_batch.len() - num_prune_packets) as u64);
-        let _ = response_sender.send(packet_batch);
+        if !packet_batch.is_empty() {
+            let _ = response_sender.send(packet_batch);
+        }
     }
 
     fn require_stake_for_gossip(&self, stakes: &HashMap<Pubkey, u64>) -> bool {
@@ -2411,16 +2494,21 @@ impl ClusterInfo {
 
         // Check if there is a duplicate instance of
         // this node with more recent timestamp.
-        let instance = self.instance.read().unwrap();
-        let check_duplicate_instance = |values: &[CrdsValue]| {
-            if should_check_duplicate_instance {
-                for value in values {
-                    if instance.check_duplicate(value) {
-                        return Err(GossipError::DuplicateNodeInstance);
-                    }
+        let check_duplicate_instance = {
+            let instance = self.instance.read().unwrap();
+            let my_contact_info = self.my_contact_info();
+            move |values: &[CrdsValue]| {
+                if should_check_duplicate_instance
+                    && values.iter().any(|value| {
+                        instance.check_duplicate(value)
+                            || matches!(&value.data, CrdsData::ContactInfo(other)
+                                if my_contact_info.check_duplicate(other))
+                    })
+                {
+                    return Err(GossipError::DuplicateNodeInstance);
                 }
+                Ok(())
             }
-            Ok(())
         };
         let mut pings = Vec::new();
         let mut rng = rand::thread_rng();
@@ -2806,6 +2894,16 @@ pub struct Sockets {
     pub tpu_forwards_quic: UdpSocket,
 }
 
+pub struct NodeConfig {
+    pub gossip_addr: SocketAddr,
+    pub port_range: PortRange,
+    pub bind_ip_addr: IpAddr,
+    pub public_tpu_addr: Option<SocketAddr>,
+    pub public_tpu_forwards_addr: Option<SocketAddr>,
+    /// The number of TVU sockets to create
+    pub num_tvu_sockets: NonZeroUsize,
+}
+
 #[derive(Debug)]
 pub struct Node {
     pub info: ContactInfo,
@@ -2998,19 +3096,22 @@ impl Node {
         }
     }
 
-    pub fn new_with_external_ip(
-        pubkey: &Pubkey,
-        gossip_addr: &SocketAddr,
-        port_range: PortRange,
-        bind_ip_addr: IpAddr,
-        public_tpu_addr: Option<SocketAddr>,
-        public_tpu_forwards_addr: Option<SocketAddr>,
-    ) -> Node {
+    pub fn new_with_external_ip(pubkey: &Pubkey, config: NodeConfig) -> Node {
+        let NodeConfig {
+            gossip_addr,
+            port_range,
+            bind_ip_addr,
+            public_tpu_addr,
+            public_tpu_forwards_addr,
+            num_tvu_sockets,
+        } = config;
+
         let (gossip_port, (gossip, ip_echo)) =
-            Self::get_gossip_port(gossip_addr, port_range, bind_ip_addr);
+            Self::get_gossip_port(&gossip_addr, port_range, bind_ip_addr);
 
         let (tvu_port, tvu_sockets) =
-            multi_bind_in_range(bind_ip_addr, port_range, 8).expect("tvu multi_bind");
+            multi_bind_in_range(bind_ip_addr, port_range, num_tvu_sockets.get())
+                .expect("tvu multi_bind");
         let (tvu_quic_port, tvu_quic) = Self::bind(bind_ip_addr, port_range);
         let (tpu_port, tpu_sockets) =
             multi_bind_in_range(bind_ip_addr, port_range, 32).expect("tpu multi_bind");
@@ -3230,7 +3331,7 @@ mod tests {
         super::*,
         crate::{
             crds_gossip_pull::tests::MIN_NUM_BLOOM_FILTERS,
-            crds_value::{CrdsValue, CrdsValueLabel, Vote as CrdsVote},
+            crds_value::{AccountsHashes, CrdsValue, CrdsValueLabel, Vote as CrdsVote},
             duplicate_shred::{self, tests::new_rand_shred, MAX_DUPLICATE_SHREDS},
             socketaddr,
         },
     }

 
     fn check_sockets(sockets: &[UdpSocket], ip: IpAddr, range: (u16, u16)) {
-        assert!(sockets.len() > 1);
+        assert!(!sockets.is_empty());
         let port = sockets[0].local_addr().unwrap().port();
         for socket in sockets.iter() {
             check_socket(socket, ip, range);
@@ -3653,14 +3753,16 @@ mod tests {
     #[test]
     fn new_with_external_ip_test_random() {
         let ip = Ipv4Addr::LOCALHOST;
-        let node = Node::new_with_external_ip(
-            &solana_sdk::pubkey::new_rand(),
-            &socketaddr!(ip, 0),
-            VALIDATOR_PORT_RANGE,
-            IpAddr::V4(ip),
-            None,
-            None,
-        );
+        let config = NodeConfig {
+            gossip_addr: socketaddr!(ip, 0),
+            port_range: VALIDATOR_PORT_RANGE,
+            bind_ip_addr: IpAddr::V4(ip),
+            public_tpu_addr: None,
+            public_tpu_forwards_addr: None,
+            num_tvu_sockets: MINIMUM_NUM_TVU_SOCKETS,
+        };
+
+        let node = Node::new_with_external_ip(&solana_sdk::pubkey::new_rand(), config);
 
         check_node_sockets(&node, IpAddr::V4(ip), VALIDATOR_PORT_RANGE);
     }
 b/gossip/src/contact_info.rs
index b3ca9c94a7..cf0322e49b 100644
--- a/gossip/src/contact_info.rs
+++ b/gossip/src/contact_info.rs
@@ -1,5 +1,6 @@
+pub use solana_client::connection_cache::Protocol;
 use {
-    crate::crds_value::MAX_WALLCLOCK,
+    crate::{crds_value::MAX_WALLCLOCK, legacy_contact_info::LegacyContactInfo},
     assert_matches::{assert_matches, debug_assert_matches},
     serde::{Deserialize, Deserializer, Serialize},
     solana_sdk::{
@@ -12,15 +13,13 @@ use {
     solana_streamer::socket::SocketAddrSpace,
     static_assertions::const_assert_eq,
     std::{
+        cmp::Ordering,
         collections::HashSet,
         net::{IpAddr, Ipv4Addr, SocketAddr},
         time::{SystemTime, UNIX_EPOCH},
     },
     thiserror::Error,
 };
-pub use {
-    crate::legacy_contact_info::LegacyContactInfo, solana_client::connection_cache::Protocol,
-};
 
 pub const SOCKET_ADDR_UNSPECIFIED: SocketAddr =
     SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), /*port:*/ 0u16);
@@ -88,7 +87,8 @@ pub struct ContactInfo {
     cache: [SocketAddr; SOCKET_CACHE_SIZE],
 }
 
-#[derive(Copy, Clone, Debug, Eq, PartialEq, AbiExample, Deserialize, Serialize)]
+#[cfg_attr(feature = "frozen-abi", derive(AbiExample))]
+#[derive(Copy, Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]
 struct SocketEntry {
     key: u8,   // Protocol identifier, e.g. tvu, tpu, etc
     index: u8, // IpAddr index in the accompanying addrs vector.
@@ -181,11 +181,7 @@ impl ContactInfo {
         Self {
             pubkey,
             wallclock,
-            outset: {
-                let now = SystemTime::now();
-                let elapsed = now.duration_since(UNIX_EPOCH).unwrap();
-                u64::try_from(elapsed.as_micros()).unwrap()
-            },
+            outset: get_node_outset(),
             shred_version,
             version: solana_version::Version::default(),
             addrs: Vec::<IpAddr>::default(),
@@ -210,8 +206,16 @@ impl ContactInfo {
         self.shred_version
     }
 
-    pub fn set_pubkey(&mut self, pubkey: Pubkey) {
-        self.pubkey = pubkey
+    #[inline]
+    pub(crate) fn version(&self) -> &solana_version::Version {
+        &self.version
+    }
+
+    pub fn hot_swap_pubkey(&mut self, pubkey: Pubkey) {
+        self.pubkey = pubkey;
+        // Need to update ContactInfo.outset so that this node's contact-info
+        // will override older node with the same pubkey.
+        self.outset = get_node_outset();
     }
 
     pub fn set_wallclock(&mut self, wallclock: u64) {
@@ -366,6 +370,29 @@ impl ContactInfo {
         LegacyContactInfo::is_valid_address(addr, socket_addr_space)
     }

+    /// Construct a ContactInfo that's only usable for gossip
+    pub fn new_gossip_entry_point(gossip_addr: &SocketAddr) -> Self {
+        let mut node = Self::new(
+            Pubkey::default(),
+            solana_sdk::timing::timestamp(), // wallclock
+            0,                               // shred_version
+        );
+        if let Err(err) = node.set_gossip(*gossip_addr) {
+            error!("Invalid entrypoint: {gossip_addr}, {err:?}");
+        }
+        node
+    }
+
     // Only for tests and simulations.
     pub fn new_localhost(pubkey: &Pubkey, wallclock: u64) -> Self {
         let mut node = Self::new(*pubkey, wallclock, /*shred_version:*/ 0u16);
@@ -407,6 +434,48 @@ impl ContactInfo {
         node.set_serve_repair_quic((addr, port + 4)).unwrap();
         node
     }
+
+    // Returns true if the other contact-info is a duplicate instance of this
+    // node, with a more recent `outset` timestamp.
+    #[inline]
+    #[must_use]
+    pub(crate) fn check_duplicate(&self, other: &ContactInfo) -> bool {
+        self.pubkey == other.pubkey && self.outset < other.outset
+    }
+
+    // Returns None if the contact-infos have different pubkey.
+    // Otherwise returns true if (self.outset, self.wallclock) tuple is larger
+    // than (other.outset, other.wallclock).
+    // If the tuples are equal it returns None.
+    #[inline]
+    #[must_use]
+    pub(crate) fn overrides(&self, other: &ContactInfo) -> Option<bool> {
+        if self.pubkey != other.pubkey {
+            return None;
+        }
+        let other = (other.outset, other.wallclock);
+        match (self.outset, self.wallclock).cmp(&other) {
+            Ordering::Less => Some(false),
+            Ordering::Greater => Some(true),
+            Ordering::Equal => None,
+        }
+    }
+}
+
+fn get_node_outset() -> u64 {
+    let now = SystemTime::now();
+    let elapsed = now.duration_since(UNIX_EPOCH).unwrap();
+    u64::try_from(elapsed.as_micros()).unwrap()
+}
+
+impl Default for ContactInfo {
+    fn default() -> Self {
+        Self::new(
+            Pubkey::default(),
+            0, // wallclock
+            0, // shred_version
+        )
+    }
 }
 
 impl<'de> Deserialize<'de> for ContactInfo {
@@ -556,7 +625,7 @@ pub(crate) fn get_quic_socket(socket: &SocketAddr) -> Result<SocketAddr, Error>
     ))
 }
 

diff --git a/gossip/src/crds.rs b/gossip/src/crds.rs
index 210c7a05aa..4a0296f797 100644
--- a/gossip/src/crds.rs
+++ b/gossip/src/crds.rs
@@ -26,11 +26,11 @@
 
 use {
     crate::{
+        contact_info::ContactInfo,
         crds_entry::CrdsEntry,
         crds_gossip_pull::CrdsTimeouts,
         crds_shards::CrdsShards,
         crds_value::{CrdsData, CrdsValue, CrdsValueLabel},
-        legacy_contact_info::LegacyContactInfo as ContactInfo,
     },
     assert_matches::debug_assert_matches,
     bincode::serialize,
@@ -195,14 +195,21 @@ impl Default for Crds {
 // Both values should have the same key/label.
 fn overrides(value: &CrdsValue, other: &VersionedCrdsValue) -> bool {
     assert_eq!(value.label(), other.value.label(), "labels mismatch!");
-    // Node instances are special cased so that if there are two running
-    // instances of the same node, the more recent start is propagated through
-    // gossip regardless of wallclocks.
+    // Contact-infos and node instances are special cased so that if there are
+    // two running instances of the same node, the more recent start is
+    // propagated through gossip regardless of wallclocks.
     if let CrdsData::NodeInstance(value) = &value.data {
         if let Some(out) = value.overrides(&other.value) {
             return out;
         }
     }
+    if let CrdsData::ContactInfo(value) = &value.data {
+        if let CrdsData::ContactInfo(other) = &other.value.data {
+            if let Some(out) = value.overrides(other) {
+                return out;
+            }
+        }
+    }
     match value.wallclock().cmp(&other.value.wallclock()) {
         Ordering::Less => false,
         Ordering::Greater => true,
@@ -243,7 +250,7 @@ impl Crds {
                 let entry_index = entry.index();
                 self.shards.insert(entry_index, &value);
                 match &value.value.data {
-                    CrdsData::LegacyContactInfo(node) => {
+                    CrdsData::ContactInfo(node) => {
                         self.nodes.insert(entry_index);
                         self.shred_versions.insert(pubkey, node.shred_version());
                     }
@@ -270,14 +277,11 @@ impl Crds {
                 self.shards.remove(entry_index, entry.get());
                 self.shards.insert(entry_index, &value);
                 match &value.value.data {
-                    CrdsData::LegacyContactInfo(node) => {
+                    CrdsData::ContactInfo(node) => {
                         self.shred_versions.insert(pubkey, node.shred_version());
                         // self.nodes does not need to be updated since the
                         // entry at this index was and stays contact-info.
-                        debug_assert_matches!(
-                            entry.get().value.data,
-                            CrdsData::LegacyContactInfo(_)
-                        );
+                        debug_assert_matches!(entry.get().value.data, CrdsData::ContactInfo(_));
                     }
                     CrdsData::Vote(_, _) => {
                         self.votes.remove(&entry.get().ordinal);
@@ -351,7 +355,7 @@ impl Crds {
     /// Returns ContactInfo of all known nodes.
     pub(crate) fn get_nodes_contact_info(&self) -> impl Iterator<Item = &ContactInfo> {
         self.get_nodes().map(|v| match &v.value.data {
-            CrdsData::LegacyContactInfo(info) => info,
+            CrdsData::ContactInfo(info) => info,
             _ => panic!("this should not happen!"),
         })
     }
@@ -480,7 +484,7 @@ impl Crds {
         // It suffices to only overwrite the origin's timestamp since that is
         // used when purging old values. If the origin does not exist in the
         // table, fallback to exhaustive update on all associated records.
-        let origin = CrdsValueLabel::LegacyContactInfo(*pubkey);
+        let origin = CrdsValueLabel::ContactInfo(*pubkey);
         if let Some(origin) = self.table.get_mut(&origin) {
             if origin.local_timestamp < now {
                 origin.local_timestamp = now;
@@ -509,7 +513,7 @@ impl Crds {
             let timeout = timeouts[pubkey];
             // If the origin's contact-info hasn't expired yet then preserve
             // all associated values.
-            let origin = CrdsValueLabel::LegacyContactInfo(*pubkey);
+            let origin = CrdsValueLabel::ContactInfo(*pubkey);
             if let Some(origin) = self.table.get(&origin) {
                 if origin
                     .value
@@ -552,7 +556,7 @@ impl Crds {
         self.purged.push_back((value.value_hash, now));
         self.shards.remove(index, &value);
         match value.value.data {
-            CrdsData::LegacyContactInfo(_) => {
+            CrdsData::ContactInfo(_) => {
                 self.nodes.swap_remove(&index);
             }
             CrdsData::Vote(_, _) => {
@@ -588,7 +592,7 @@ impl Crds {
             self.shards.remove(size, value);
             self.shards.insert(index, value);
             match value.value.data {
-                CrdsData::LegacyContactInfo(_) => {
+                CrdsData::ContactInfo(_) => {
                     self.nodes.swap_remove(&size);
                     self.nodes.insert(index);
                 }

diff --git a/gossip/src/crds_entry.rs b/gossip/src/crds_entry.rs
index 526f04eb56..9c37b264cc 100644
--- a/gossip/src/crds_entry.rs
+++ b/gossip/src/crds_entry.rs
@@ -1,10 +1,10 @@
 use {
     crate::{
+        contact_info::ContactInfo,
         crds::VersionedCrdsValue,
         crds_value::{
             CrdsData, CrdsValue, CrdsValueLabel, LegacyVersion, LowestSlot, SnapshotHashes, Version,
         },
-        legacy_contact_info::LegacyContactInfo,
     },
     indexmap::IndexMap,
     solana_sdk::pubkey::Pubkey,
@@ -52,7 +52,7 @@ impl_crds_entry!(CrdsValue, |entry| Some(&entry?.value));
 impl_crds_entry!(VersionedCrdsValue, |entry| entry);
 
 // Lookup by Pubkey.
-impl_crds_entry!(LegacyContactInfo, CrdsData::LegacyContactInfo(node), node);
+impl_crds_entry!(ContactInfo, CrdsData::ContactInfo(node), node);
 impl_crds_entry!(LegacyVersion, CrdsData::LegacyVersion(version), version);
 impl_crds_entry!(LowestSlot, CrdsData::LowestSlot(_, slot), slot);
 impl_crds_entry!(Version, CrdsData::Version(version), version);
@@ -102,8 +102,8 @@ mod tests {
             assert_eq!(crds.get::<&VersionedCrdsValue>(&key).unwrap().value, *entry);
             let key = entry.pubkey();
             match &entry.data {
-                CrdsData::LegacyContactInfo(node) => {
-                    assert_eq!(crds.get::<&LegacyContactInfo>(key), Some(node))
+                CrdsData::ContactInfo(node) => {
+                    assert_eq!(crds.get::<&ContactInfo>(key), Some(node))
                 }
                 CrdsData::LowestSlot(_, slot) => {
                     assert_eq!(crds.get::<&LowestSlot>(key), Some(slot))
diff --git a/gossip/src/crds_gossip.rs b/gossip/src/crds_gossip.rs
index 99f40d4915..788e9f9af8 100644
--- a/gossip/src/crds_gossip.rs
+++ b/gossip/src/crds_gossip.rs
@@ -8,13 +8,13 @@ use {
     crate::{
         cluster_info::Ping,
         cluster_info_metrics::GossipStats,
+        contact_info::ContactInfo,
         crds::{Crds, GossipRoute},
         crds_gossip_error::CrdsGossipError,
         crds_gossip_pull::{CrdsFilter, CrdsGossipPull, CrdsTimeouts, ProcessPullStats},
         crds_gossip_push::CrdsGossipPush,
         crds_value::{CrdsData, CrdsValue},
         duplicate_shred::{self, DuplicateShredIndex, MAX_DUPLICATE_SHREDS},
-        legacy_contact_info::LegacyContactInfo as ContactInfo,
         ping_pong::PingCache,
     },
     itertools::Itertools,
@@ -209,7 +209,7 @@ impl CrdsGossip {
         ping_cache: &Mutex<PingCache>,
         pings: &mut Vec<(SocketAddr, Ping)>,
         socket_addr_space: &SocketAddrSpace,
-    ) -> Result<HashMap<ContactInfo, Vec<CrdsFilter>>, CrdsGossipError> {
+    ) -> Result<Vec<(ContactInfo, Vec<CrdsFilter>)>, CrdsGossipError> {
         self.pull.new_pull_request(
             thread_pool,
             &self.crds,
@@ -433,7 +433,7 @@ mod test {
             .write()
             .unwrap()
             .insert(
-                CrdsValue::new_unsigned(CrdsData::LegacyContactInfo(ci.clone())),
+                CrdsValue::new_unsigned(CrdsData::ContactInfo(ci.clone())),
                 0,
                 GossipRoute::LocalMessage,
             )
diff --git a/gossip/src/crds_gossip_pull.rs b/gossip/src/crds_gossip_pull.rs
index 7f70e79bf0..d440dad2a4 100644
--- a/gossip/src/crds_gossip_pull.rs
+++ b/gossip/src/crds_gossip_pull.rs
@@ -15,14 +15,13 @@ use {
     crate::{
         cluster_info::Ping,
         cluster_info_metrics::GossipStats,
+        contact_info::ContactInfo,
         crds::{Crds, GossipRoute, VersionedCrdsValue},
         crds_gossip,
         crds_gossip_error::CrdsGossipError,
         crds_value::CrdsValue,
-        legacy_contact_info::LegacyContactInfo as ContactInfo,
         ping_pong::PingCache,
     },
-    itertools::Itertools,
     rand::{
         distributions::{Distribution, WeightedIndex},
         Rng,
@@ -37,7 +36,7 @@ use {
     },
     solana_streamer::socket::SocketAddrSpace,
     std::{
-        collections::{HashMap, HashSet, VecDeque},
+        collections::{hash_map::Entry, HashMap, HashSet, VecDeque},
         convert::TryInto,
         iter::{repeat, repeat_with},
         net::SocketAddr,
@@ -56,7 +55,8 @@ const FAILED_INSERTS_RETENTION_MS: u64 = 20_000;
 pub const FALSE_RATE: f64 = 0.1f64;
 pub const KEYS: f64 = 8f64;
 
-#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, AbiExample)]
+#[cfg_attr(feature = "frozen-abi", derive(AbiExample))]
+#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
 pub struct CrdsFilter {
     pub filter: Bloom<Hash>,
     mask: u64,
@@ -238,7 +238,7 @@ impl CrdsGossipPull {
         ping_cache: &Mutex<PingCache>,
         pings: &mut Vec<(SocketAddr, Ping)>,
         socket_addr_space: &SocketAddrSpace,
-    ) -> Result<HashMap<ContactInfo, Vec<CrdsFilter>>, CrdsGossipError> {
+    ) -> Result<Vec<(ContactInfo, Vec<CrdsFilter>)>, CrdsGossipError> {
         let mut rng = rand::thread_rng();
         // Active and valid gossip nodes with matching shred-version.
         let nodes = crds_gossip::get_gossip_nodes(
@@ -281,8 +281,17 @@ impl CrdsGossipPull {
         let filters = self.build_crds_filters(thread_pool, crds, bloom_size);
         // Associate each pull-request filter with a randomly selected peer.
         let dist = WeightedIndex::new(weights).unwrap();
-        let nodes = repeat_with(|| nodes[dist.sample(&mut rng)].clone());
-        Ok(nodes.zip(filters).into_group_map())
+        let out = filters.into_iter().fold(HashMap::new(), |mut out, filter| {
+            let node = &nodes[dist.sample(&mut rng)];
+            match out.entry(*node.pubkey()) {
+                Entry::Vacant(entry) => {
+                    entry.insert((node.clone(), vec![filter]));
+                }
+                Entry::Occupied(mut entry) => entry.get_mut().1.push(filter),
+            };
+            out
+        });
+        Ok(out.into_values().collect())
     }
 
    
diff --git a/gossip/src/crds_gossip_push.rs b/gossip/src/crds_gossip_push.rs
index 72ffc30a48..49f04f6cd3 100644
--- a/gossip/src/crds_gossip_push.rs
+++ b/gossip/src/crds_gossip_push.rs
@@ -21,10 +21,8 @@ use {
         push_active_set::PushActiveSet,
         received_cache::ReceivedCache,
     },
-    bincode::serialized_size,
     itertools::Itertools,
     solana_sdk::{
-        packet::PACKET_DATA_SIZE,
         pubkey::Pubkey,
         signature::{Keypair, Signer},
         timing::timestamp,
@@ -53,8 +51,6 @@ const CRDS_GOSSIP_PRUNE_MIN_INGRESS_NODES: usize = 2;
 const CRDS_GOSSIP_PUSH_ACTIVE_SET_SIZE: usize = CRDS_GOSSIP_PUSH_FANOUT + 3;
 
 pub struct CrdsGossipPush {
-    /// Max bytes per message
-    max_bytes: usize,
     /// Active set of validators for push
     active_set: RwLock<PushActiveSet>,
     /// Cursor into the crds table for values to push.
@@ -74,8 +70,6 @@ pub struct CrdsGossipPush {
 impl Default for CrdsGossipPush {
     fn default() -> Self {
         Self {
-            // Allow upto 64 Crds Values per PUSH
-            max_bytes: PACKET_DATA_SIZE * 64,
             active_set: RwLock::default(),
             crds_cursor: Mutex::default(),
             received_cache: Mutex::new(ReceivedCache::new(2 * CRDS_UNIQUE_PUBKEY_CAPACITY)),
@@ -180,10 +174,10 @@ impl CrdsGossipPush {
         usize, // number of values
         usize, // number of push messages
     ) {
+        const MAX_NUM_PUSHES: usize = 1 << 12;
         let active_set = self.active_set.read().unwrap();
         let mut num_pushes = 0;
         let mut num_values = 0;
-        let mut total_bytes: usize = 0;
         let mut push_messages: HashMap<Pubkey, Vec<CrdsValue>> = HashMap::new();
         let wallclock_window = self.wallclock_window(now);
         let mut crds_cursor = self.crds_cursor.lock().unwrap();
@@ -193,12 +187,7 @@ impl CrdsGossipPush {
             .get_entries(crds_cursor.deref_mut())
             .map(|entry| &entry.value)
             .filter(|value| wallclock_window.contains(&value.wallclock()));
-        for value in entries {
-            let serialized_size = serialized_size(&value).unwrap();
-            total_bytes = total_bytes.saturating_add(serialized_size as usize);
-            if total_bytes > self.max_bytes {
-                break;
-            }
+        'outer: for value in entries {
             num_values += 1;
             let origin = value.pubkey();
             let nodes = active_set.get_nodes(
@@ -210,6 +199,9 @@ impl CrdsGossipPush {
             for node in nodes.take(self.push_fanout) {
                 push_messages.entry(*node).or_default().push(value.clone());
                 num_pushes += 1;
+                if num_pushes >= MAX_NUM_PUSHES {
+                    break 'outer;
+                }
             }
         }
         drop(crds);
@@ -288,7 +280,7 @@ impl CrdsGossipPush {
 mod tests {
     use {
         super::*,
-        crate::{crds_value::CrdsData, legacy_contact_info::LegacyContactInfo as ContactInfo},
+        crate::{contact_info::ContactInfo, crds_value::CrdsData},
         std::time::{Duration, Instant},
     };
 
diff --git a/gossip/src/crds_value.rs b/gossip/src/crds_value.rs
index 967cbfa4b9..e3f35fd66a 100644
--- a/gossip/src/crds_value.rs
+++ b/gossip/src/crds_value.rs
@@ -41,7 +41,8 @@ pub type EpochSlotsIndex = u8;
 pub const MAX_EPOCH_SLOTS: EpochSlotsIndex = 255;
 
 /// CrdsValue that is replicated across the cluster
-#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, AbiExample)]
+#[cfg_attr(feature = "frozen-abi", derive(AbiExample))]
+#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
 pub struct CrdsValue {
     pub signature: Signature,
     pub data: CrdsData,
@@ -81,13 +82,15 @@ impl Signable for CrdsValue {
 /// * Merge Strategy - Latest wallclock is picked
 /// * LowestSlot index is deprecated
 #[allow(clippy::large_enum_variant)]
-#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, AbiExample, AbiEnumVisitor)]
+#[cfg_attr(feature = "frozen-abi", derive(AbiExample, AbiEnumVisitor))]
+#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
 pub enum CrdsData {
+    #[allow(private_interfaces)]
     LegacyContactInfo(LegacyContactInfo),
     Vote(VoteIndex, Vote),
     LowestSlot(/*DEPRECATED:*/ u8, LowestSlot),
     LegacySnapshotHashes(LegacySnapshotHashes), // Deprecated
-    AccountsHashes(AccountsHashes),
+    AccountsHashes(AccountsHashes),             // Deprecated
     EpochSlots(EpochSlotsIndex, EpochSlots),
     LegacyVersion(LegacyVersion),
     Version(Version),
@@ -155,7 +158,7 @@ impl CrdsData {
    
 
-    pub(crate) fn contact_info(&self) -> Option<&LegacyContactInfo> {
+    pub(crate) fn contact_info(&self) -> Option<&ContactInfo> {
         match &self.data {
-            CrdsData::LegacyContactInfo(contact_info) => Some(contact_info),
-            _ => None,
-        }
-    }
-
-    pub(crate) fn accounts_hash(&self) -> Option<&AccountsHashes> {
-        match &self.data {
-            CrdsData::AccountsHashes(slots) => Some(slots),
+            CrdsData::ContactInfo(contact_info) => Some(contact_info),
             _ => None,
         }
     }

 
-#[derive(Serialize, Deserialize, Clone, Default, PartialEq, Eq, AbiExample)]
+#[cfg_attr(feature = "frozen-abi", derive(AbiExample))]
+#[derive(Serialize, Deserialize, Clone, Default, PartialEq, Eq)]
 pub struct EpochSlots {
     pub from: Pubkey,
     pub slots: Vec<CompressedSlots>,
diff --git a/gossip/src/gossip_service.rs b/gossip/src/gossip_service.rs
index 95ca05ee1f..b35cf1c584 100644
--- a/gossip/src/gossip_service.rs
+++ b/gossip/src/gossip_service.rs
@@ -1,10 +1,13 @@
 //! The `gossip_service` module implements the network control plane.
 
 use {
-    crate::{cluster_info::ClusterInfo, legacy_contact_info::LegacyContactInfo as ContactInfo},
+    crate::{cluster_info::ClusterInfo, contact_info::ContactInfo},
     crossbeam_channel::{unbounded, Sender},
     rand::{thread_rng, Rng},
-    solana_client::{connection_cache::ConnectionCache, thin_client::ThinClient},
+    solana_client::{
+        connection_cache::ConnectionCache, rpc_client::RpcClient, tpu_client::TpuClientWrapper,
+    },
+    solana_net_utils::DEFAULT_IP_ECHO_SERVER_THREADS,
     solana_perf::recycler::Recycler,
     solana_runtime::bank_forks::BankForks,
     solana_sdk::{
@@ -15,6 +18,7 @@ use {
         socket::SocketAddrSpace,
         streamer::{self, StreamerReceiveStats},
     },
+    solana_tpu_client::tpu_client::{TpuClient, TpuClientConfig},
     std::{
         collections::HashSet,
         net::{SocketAddr, TcpListener, UdpSocket},
@@ -50,6 +54,7 @@ impl GossipService {
         );
         let socket_addr_space = *cluster_info.socket_addr_space();
         let t_receiver = streamer::receiver(
+            "solRcvrGossip".to_string(),
             gossip_socket.clone(),
             exit.clone(),
             request_sender,
@@ -156,8 +161,14 @@ pub fn discover(
     if let Some(my_gossip_addr) = my_gossip_addr {
         info!("Gossip Address: {:?}", my_gossip_addr);
     }
-    let _ip_echo_server = ip_echo
-        .map(|tcp_listener| solana_net_utils::ip_echo_server(tcp_listener, Some(my_shred_version)));
+
+    let _ip_echo_server = ip_echo.map(|tcp_listener| {
+        solana_net_utils::ip_echo_server(
+            tcp_listener,
+            DEFAULT_IP_ECHO_SERVER_THREADS,
+            Some(my_shred_version),
+        )
+    });
     let (met_criteria, elapsed, all_peers, tvu_peers) = spy(
         spy_ref.clone(),
         num_nodes,
@@ -193,39 +204,40 @@ pub fn discover(
     ))
 }
 
 fn spy(
@@ -272,7 +284,7 @@ fn spy(
         if let Some(num) = num_nodes {
             // Only consider validators and archives for `num_nodes`
             let mut nodes: Vec<_> = tvu_peers.iter().collect();
-            nodes.sort();
+            nodes.sort_unstable_by_key(|node| node.pubkey());
             nodes.dedup();
 
             if nodes.len() >= num {
diff --git a/gossip/src/legacy_contact_info.rs b/gossip/src/legacy_contact_info.rs
index d3dead1910..f43998d00b 100644
--- a/gossip/src/legacy_contact_info.rs
+++ b/gossip/src/legacy_contact_info.rs
@@ -1,25 +1,24 @@
+#[cfg(test)]
+use crate::contact_info::{get_quic_socket, sanitize_socket};
 use {
     crate::{
         contact_info::{
-            get_quic_socket, sanitize_quic_offset, sanitize_socket, ContactInfo, Error, Protocol,
-            SOCKET_ADDR_UNSPECIFIED,
+            sanitize_quic_offset, ContactInfo, Error, Protocol, SOCKET_ADDR_UNSPECIFIED,
         },
         crds_value::MAX_WALLCLOCK,
     },
     solana_sdk::{
         pubkey::Pubkey,
         sanitize::{Sanitize, SanitizeError},
-        timing::timestamp,
     },
     solana_streamer::socket::SocketAddrSpace,
-    std::net::{IpAddr, Ipv4Addr, SocketAddr},
+    std::net::{IpAddr, SocketAddr},
 };
 
 /// Structure representing a node on the network
-#[derive(
-    Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, AbiExample, Deserialize, Serialize,
-)]
-pub struct LegacyContactInfo {
+#[cfg_attr(feature = "frozen-abi", derive(AbiExample))]
+#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]
+pub(crate) struct LegacyContactInfo {
     id: Pubkey,
     /// gossip address
     gossip: SocketAddr,
@@ -58,14 +57,16 @@ impl Sanitize for LegacyContactInfo {
 
 macro_rules! get_socket {
     ($name:ident) => {
-        pub fn $name(&self) -> Result<SocketAddr, Error> {
+        #[cfg(test)]
+        pub(crate) fn $name(&self) -> Result<SocketAddr, Error> {
             let socket = &self.$name;
             sanitize_socket(socket)?;
             Ok(socket).copied()
         }
     };
     ($name:ident, $quic:ident) => {
-        pub fn $name(&self, protocol: Protocol) -> Result<SocketAddr, Error> {
+        #[cfg(test)]
+        pub(crate) fn $name(&self, protocol: Protocol) -> Result<SocketAddr, Error> {
             let socket = match protocol {
                 Protocol::QUIC => &self.$quic,
                 Protocol::UDP => &self.$name,
@@ -75,7 +76,8 @@ macro_rules! get_socket {
         }
     };
     (@quic $name:ident) => {
-        pub fn $name(&self, protocol: Protocol) -> Result<SocketAddr, Error> {
+        #[cfg(test)]
+        pub(crate) fn $name(&self, protocol: Protocol) -> Result<SocketAddr, Error> {
             let socket = &self.$name;
             sanitize_socket(socket)?;
             match protocol {
@@ -86,20 +88,6 @@ macro_rules! get_socket {
     };
 }
 
-macro_rules! set_socket {
-    ($name:ident, $key:ident) => {
-        pub fn $name<T>(&mut self, socket: T) -> Result<(), Error>
-        where
-            SocketAddr: From<T>,
-        {
-            let socket = SocketAddr::from(socket);
-            sanitize_socket(&socket)?;
-            self.$key = socket;
-            Ok(())
-        }
-    };
-}
-
 #[macro_export]
 macro_rules! socketaddr {
     ($ip:expr, $port:expr) => {
@@ -117,6 +105,7 @@ macro_rules! socketaddr_any {
     };
 }
 
+#[cfg(test)]
 impl Default for LegacyContactInfo {
     fn default() -> Self {
         LegacyContactInfo {
@@ -138,73 +127,27 @@ impl Default for LegacyContactInfo {
 }
 
 impl LegacyContactInfo {
-    pub fn new_localhost(id: &Pubkey, now: u64) -> Self {
-        Self {
-            id: *id,
-            gossip: socketaddr!(Ipv4Addr::LOCALHOST, 1234),
-            tvu: socketaddr!(Ipv4Addr::LOCALHOST, 1235),
-            tvu_quic: socketaddr!(Ipv4Addr::LOCALHOST, 1236),
-            serve_repair_quic: socketaddr!(Ipv4Addr::LOCALHOST, 1237),
-            tpu: socketaddr!(Ipv4Addr::LOCALHOST, 1238),
-            tpu_forwards: socketaddr!(Ipv4Addr::LOCALHOST, 1239),
-            tpu_vote: socketaddr!(Ipv4Addr::LOCALHOST, 1240),
-            rpc: socketaddr!(Ipv4Addr::LOCALHOST, 1241),
-            rpc_pubsub: socketaddr!(Ipv4Addr::LOCALHOST, 1242),
-            serve_repair: socketaddr!(Ipv4Addr::LOCALHOST, 1243),
-            wallclock: now,
-            shred_version: 0,
-        }
-    }
-
-
-    // Construct a LegacyContactInfo that's only usable for gossip
-    pub fn new_gossip_entry_point(gossip_addr: &SocketAddr) -> Self {
-        Self {
-            id: Pubkey::default(),
-            gossip: *gossip_addr,
-            wallclock: timestamp(),
-            ..LegacyContactInfo::default()
-        }
-    }
-
     #[inline]
-    pub fn pubkey(&self) -> &Pubkey {
+    pub(crate) fn pubkey(&self) -> &Pubkey {
         &self.id
     }
 
     #[inline]
-    pub fn wallclock(&self) -> u64 {
+    pub(crate) fn wallclock(&self) -> u64 {
         self.wallclock
     }
 
     #[inline]
-    pub fn shred_version(&self) -> u16 {
+    pub(crate) fn shred_version(&self) -> u16 {
         self.shred_version
     }
 
-    pub fn set_pubkey(&mut self, pubkey: Pubkey) {
-        self.id = pubkey
-    }
-
-    pub fn set_wallclock(&mut self, wallclock: u64) {
-        self.wallclock = wallclock;
+    pub(crate) fn gossip(&self) -> Result<SocketAddr, Error> {
+        let socket = &self.gossip;
+        crate::contact_info::sanitize_socket(socket)?;
+        Ok(socket).copied()
     }
 
-    #[cfg(test)]
-    pub(crate) fn set_shred_version(&mut self, shred_version: u16) {
-        self.shred_version = shred_version
-    }
-
-    get_socket!(gossip);
     get_socket!(tvu, tvu_quic);
     get_socket!(@quic tpu);
     get_socket!(@quic tpu_forwards);
@@ -213,9 +156,6 @@ impl LegacyContactInfo {
     get_socket!(rpc_pubsub);
     get_socket!(serve_repair, serve_repair_quic);
 
-    set_socket!(set_gossip, gossip);
-    set_socket!(set_rpc, rpc);
-
     fn is_valid_ip(addr: IpAddr) -> bool {
         !(addr.is_unspecified() || addr.is_multicast())
         // || (addr.is_loopback() && !cfg_test))
@@ -226,24 +166,9 @@ impl LegacyContactInfo {
     /// ip must be specified and not multicast
     /// loopback ip is only allowed in tests
     // TODO: Replace this entirely with streamer SocketAddrSpace.
-    pub fn is_valid_address(addr: &SocketAddr, socket_addr_space: &SocketAddrSpace) -> bool {
+    pub(crate) fn is_valid_address(addr: &SocketAddr, socket_addr_space: &SocketAddrSpace) -> bool {
         addr.port() != 0u16 && Self::is_valid_ip(addr.ip()) && socket_addr_space.check(addr)
     }
-
-    pub(crate) fn valid_client_facing_addr(
-        &self,
-        protocol: Protocol,
-        socket_addr_space: &SocketAddrSpace,
-    ) -> Option<(SocketAddr, SocketAddr)> {
-        Some((
-            self.rpc()
-                .ok()
-                .filter(|addr| socket_addr_space.check(addr))?,
-            self.tpu(protocol)
-                .ok()
-                .filter(|addr| socket_addr_space.check(addr))?,
-        ))
-    }
 }
 
 impl TryFrom<&ContactInfo> for LegacyContactInfo {
@@ -288,7 +213,7 @@ impl TryFrom<&ContactInfo> for LegacyContactInfo {
 
diff --git a/gossip/src/ping_pong.rs b/gossip/src/ping_pong.rs
index d34f9ae343..5d4839cfa9 100644
--- a/gossip/src/ping_pong.rs
+++ b/gossip/src/ping_pong.rs
@@ -18,14 +18,16 @@ use {
 
 const PING_PONG_HASH_PREFIX: &[u8] = "SOLANA_PING_PONG".as_bytes();
 
-#[derive(AbiExample, Debug, Deserialize, Serialize)]
+#[cfg_attr(feature = "frozen-abi", derive(AbiExample))]
+#[derive(Debug, Deserialize, Serialize)]
 pub struct Ping<T> {
     from: Pubkey,
     token: T,
     signature: Signature,
 }
 
-#[derive(AbiExample, Debug, Deserialize, Serialize)]
+#[cfg_attr(feature = "frozen-abi", derive(AbiExample))]
+#[derive(Debug, Deserialize, Serialize)]
 pub struct Pong {
     from: Pubkey,
     hash: Hash, // Hash of received ping token.
