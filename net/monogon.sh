#!/usr/bin/env bash
set -e

here=$(dirname "$0")
# shellcheck source=net/common.sh
source "$here"/common.sh

namespace=testnet-dev-${USER//[^A-Za-z0-9]/}
additionalValidatorCount=2
clientNodeCount=0
blockstreamer=false

usage() {
  exitcode=0
  if [[ -n "$1" ]]; then
    exitcode=1
    echo "Error: $*"
  fi
  cat <<EOF
usage: $0 [create|delete] [common options]

Manage monogon instances
 create - create a new testnet (implies 'config')
 config - configure the testnet and write a config file describing it
 delete - delete the testnet

 common options:
   -p [namespace]      - Optional namespace for deployment
   -n [number]         - Number of additional validators (default: $additionalValidatorCount)
   -c [number]         - Number of client nodes (default: $clientNodeCount)
   -u                  - Include a Blockstreamer (default: $blockstreamer)
EOF
  exit $exitcode
}

stop() {
    namespaceStatus=$(kubectl get ns "$namespace" -o json --ignore-not-found | jq .status.phase -r)
    if [ "$namespaceStatus" = "Active" ]
    then
        echo "Deleting namespace $namespace ..."
        kubectl delete ns "$namespace"
    else 
        echo "Namespace $namespace doesn't exist"
    fi
}

deploy() {
    $metricsWriteDatapoint "testnet-deploy net-create-begin=1"

    echo "Creating Namespace $namespace..."
    kubectl create ns "$namespace" 

    echo "Deploying bootstrap deployment/service"
    deployBootstrapValidatorDeployments

    echo "Deploying validator deployments/services"
    deployValidatorDeployments

    buildInstanceStartupScript

    echo "installing required libraries..."
    installRequiredLibraries

    $metricsWriteDatapoint "testnet-deploy net-create-complete=1"

}

deployBootstrapValidatorDeployments() {
    kubectl apply -f "$here/k8s-cluster/deployments/bootstrap-validator.yaml" --namespace=$namespace
    
    ATTEMPTS=0
    ROLLOUT_STATUS_COMMAND="kubectl rollout status deployment/solana-bootstrap-validator-deployment -n $namespace"
    until $ROLLOUT_STATUS_COMMAND || [ $ATTEMPTS -eq 10 ]; do
        $ROLLOUT_STATUS_COMMAND
        ATTEMPTS=$((attempts + 1))
        sleep 2
    done
}

installRequiredLibraries() {
    POD_NAMES=$(kubectl get pods -n $namespace -o jsonpath='{.items[*].metadata.name}')

    # Loop through each pod and run apt update
    for POD_NAME in $POD_NAMES; do
        updateAndInstall $POD_NAME &
    done

    wait
    echo "finished installing libraries"
}

# TODO: Possible add startup script from gce.sh here
# it's with name/path: net/config/instance-startup-script.sh
updateAndInstall() {
    local pod_name=$1
    echo "Updating pod: $pod_name"
    kubectl exec -i $pod_name -n $namespace -- sh -c "apt-get update && apt-get install -y iputils-ping curl vim bzip2 psmisc iproute2 software-properties-common apt-transport-https ca-certificates openssh-client openssh-server"
    kubectl cp $netConfigDir/instance-startup-script.sh $namespace/$pod_name:/
    kubectl exec -i $pod_name -n $namespace -- sh -c "chmod +x /instance-startup-script.sh && /instance-startup-script.sh"
}

deployValidatorDeployments() {
    sed -i.bak "s/replicas: .*/replicas: $additionalValidatorCount/" $here/k8s-cluster/deployments/validator.yaml

    kubectl apply -f "$here/k8s-cluster/deployments/validator.yaml" --namespace=$namespace
    ATTEMPTS=0
    ROLLOUT_STATUS_COMMAND="kubectl rollout status deployment/solana-validator-deployment -n $namespace"
    until $ROLLOUT_STATUS_COMMAND || [ $ATTEMPTS -eq 10 ]; do
        $ROLLOUT_STATUS_COMMAND
        ATTEMPTS=$((attempts + 1))
        sleep 2
    done

}


buildInstanceStartupScript() {
  sshPrivateKey="$netConfigDir/id_$namespace"
  rm -rf "$sshPrivateKey"{,.pub}

  # Note: using rsa because |aws ec2 import-key-pair| seems to fail for ecdsa
  ssh-keygen -t rsa -N '' -f "$sshPrivateKey"

  printNetworkInfo() {
    cat <<EOF
==[ Network composition ]===============================================================
  Bootstrap validator = TODO: define this?
  Additional validators = $additionalValidatorCount 
  Client(s) = $clientNodeCount
  Blockstreamer = $blockstreamer
========================================================================================

EOF
  }
  printNetworkInfo

  creationDate=$(date)
  creationInfo() {
    cat <<EOF

  Instance running since: $creationDate

========================================================================================
EOF
  }

  declare startupScript="$netConfigDir"/instance-startup-script.sh
  cat > "$startupScript" <<EOF
#!/usr/bin/env bash
# autogenerated at $(date)
set -ex

if [[ -f /solana-scratch/.instance-startup-complete ]]; then
  echo reboot
  $(
    cd "$here"/scripts/
    cat ../../scripts/ulimit-n.sh
  )
  if [[ -x ~solana/solana/on-reboot ]]; then
    su - solana ~solana/solana/on-reboot
  fi

  # Skip most setup on instance reboot
  exit 0
fi

cat > /etc/motd <<EOM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  This instance has not been fully configured.

  See startup script log messages in /var/log/syslog for status:
    $ sudo cat /var/log/syslog | egrep \\(startup-script\\|cloud-init\)

  To block until setup is complete, run:
    $ until [[ -f /solana-scratch/.instance-startup-complete ]]; do sleep 1; done

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
$(creationInfo)
EOM

# Place the generated private key at /solana-scratch/id_ecdsa so it's retrievable by anybody
# who is able to log into this machine
mkdir -m 0777 /solana-scratch
cat > /solana-scratch/id_ecdsa <<EOK
$(cat "$sshPrivateKey")
EOK
cat > /solana-scratch/id_ecdsa.pub <<EOK
$(cat "$sshPrivateKey.pub")
EOK
chmod 444 /solana-scratch/id_ecdsa

USER=\$(id -un)
export DEBIAN_FRONTEND=noninteractive
$(
  cd "$here"/scripts/
  cat \
    disable-background-upgrades.sh \
    create-solana-user-k8s.sh \
    solana-user-authorized_keys.sh \
    add-testnet-solana-user-authorized_keys-k8s.sh \
    install-ag.sh \
    install-certbot.sh \
    install-iftop.sh \
    install-libssl-compatability.sh \
    install-redis.sh \
    install-rsync.sh \
    install-perf-k8s.sh \
    localtime.sh \
)
touch /solana-scratch/.instance-startup-complete
EOF
}


command=$1
[[ -n $command ]] || usage
shift
[[ $command = create || $command = create || $command = delete ]] ||
  usage "Invalid command: $command"

shortArgs=()
while [[ -n $1 ]]; do
  shortArgs+=("$1")
  shift
done

while getopts "h?p:n:c:u" opt "${shortArgs[@]}"; do
  case $opt in
  h | \?)
    usage
    ;;
  p)
    [[ ${OPTARG//[^A-Za-z0-9-]/} == "$OPTARG" ]] || usage "Invalid namespace: \"$OPTARG\", alphanumeric only"
    namespace=$OPTARG
    ;;
  n)
    additionalValidatorCount=$OPTARG
    ;;
  c)
    clientNodeCount=$OPTARG
    ;;
  u)
    blockstreamer=true
    ;;
  *)
    usage "unhandled option: $opt"
    ;;
  esac
done

echo \
"namespace: $namespace 
validator count: $additionalValidatorCount
client count: $clientNodeCount 
blockstreamer: $blockstreamer"

case $command in 
create)
#   prepareDeploy
  stop
  deploy
  ;;
delete)
  stop
  ;;
*)
  echo "Internal error: Unknown command: $command"
  usage
  exit 1
esac